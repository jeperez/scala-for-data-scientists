{"paragraphs":[{"text":"//Cons(1, Cons(2, Nil))\n//fold(1, fold(2, z ))\ndef foldRight[A, B](list: List[A], z: B)(f:(A, B) => B): B =\n  list match {\n    case Nil => z\n    case x :: xs => f(x, foldRight(xs, z)(f))\n  }","dateUpdated":"Feb 11, 2016 2:21:20 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454961462504_546497861","id":"20160208-115742_553488728","result":{"code":"SUCCESS","type":"TEXT","msg":"foldRight: [A, B](list: List[A], z: B)(f: (A, B) => B)B\n"},"dateCreated":"Feb 8, 2016 11:57:42 AM","dateStarted":"Feb 11, 2016 2:21:20 PM","dateFinished":"Feb 11, 2016 2:21:20 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1544"},{"text":"def myToString[A](list: List[A]): String = list match {\n  case Nil => \"Nil\"\n  case head :: tail => \"Cons(\" + head + \", \" + myToString(tail) + \")\"\n}\nmyToString(List(1,2,3,4,5))","dateUpdated":"Feb 11, 2016 10:30:46 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454962660042_-564400862","id":"20160208-121740_1216299725","result":{"code":"SUCCESS","type":"TEXT","msg":"myToString: [A](list: List[A])String\nres700: String = Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, Nil)))))\n"},"dateCreated":"Feb 8, 2016 12:17:40 PM","dateStarted":"Feb 11, 2016 10:30:46 AM","dateFinished":"Feb 11, 2016 10:30:46 AM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1545"},{"text":"def foo(head: String, tail: String): String = \"Cons(\" + head + \", \" + tail + \")\"\ndef myToString2(list: List[String]) = foldRight(list,\"Nil\")(foo)\nmyToString2(List(\"1\",\"2\",\"3\",\"4\",\"5\"))","dateUpdated":"Feb 11, 2016 2:25:31 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":false},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454966755657_2077554867","id":"20160208-132555_1438871126","result":{"code":"SUCCESS","type":"TEXT","msg":"foo: (head: String, tail: String)String\nmyToString2: (list: List[String])String\nres868: String = Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, Nil)))))\n"},"dateCreated":"Feb 8, 2016 1:25:55 PM","dateStarted":"Feb 11, 2016 2:25:31 PM","dateFinished":"Feb 11, 2016 2:25:31 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1546"},{"text":"def foldLeft[A,B](list: List[A], z: B)(f: (B, A) => B): B = \n  list match {\n    case Nil => z\n    case head :: tail => foldLeft(tail,f(z,head) )(f)\n  }\n  \ndef myToString3(list: List[String]) = foldLeft(list,\"Nil\")(foo)\nmyToString3(List(\"1\",\"2\",\"3\",\"4\",\"5\"))","dateUpdated":"Feb 11, 2016 2:25:34 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":false},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454962539325_-1897707398","id":"20160208-121539_1184757499","result":{"code":"SUCCESS","type":"TEXT","msg":"foldLeft: [A, B](list: List[A], z: B)(f: (B, A) => B)B\nmyToString3: (list: List[String])String\nres871: String = Cons(Cons(Cons(Cons(Cons(Nil, 1), 2), 3), 4), 5)\n"},"dateCreated":"Feb 8, 2016 12:15:39 PM","dateStarted":"Feb 11, 2016 2:25:34 PM","dateFinished":"Feb 11, 2016 2:25:35 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1547"},{"text":"def foldRightViaFoldLeft[A,B](l: List[A], z: B)(f: (A,B) => B): B = \n  foldLeft(l.reverse, z)((b,a) => f(a,b))\n  \ndef myToString4(list: List[String]) = foldRightViaFoldLeft(list,\"Nil\")(foo)\nmyToString4(List(\"1\",\"2\",\"3\",\"4\",\"5\"))","dateUpdated":"Feb 11, 2016 2:26:36 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455229472806_-1601468572","id":"20160211-142432_701372821","result":{"code":"SUCCESS","type":"TEXT","msg":"foldRightViaFoldLeft: [A, B](l: List[A], z: B)(f: (A, B) => B)B\nmyToString4: (list: List[String])String\nres877: String = Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, Nil)))))\n"},"dateCreated":"Feb 11, 2016 2:24:32 PM","dateStarted":"Feb 11, 2016 2:26:36 PM","dateFinished":"Feb 11, 2016 2:26:36 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1548"},{"text":"//difference between Reduce and foldLeft\n//http://stackoverflow.com/questions/25158780/difference-between-reduce-and-foldleft-fold-in-functional-programming-particula","dateUpdated":"Feb 8, 2016 1:56:36 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454965542671_689429574","id":"20160208-130542_1354177213","result":{"code":"SUCCESS","type":"TEXT","msg":""},"dateCreated":"Feb 8, 2016 1:05:42 PM","dateStarted":"Feb 8, 2016 1:09:27 PM","dateFinished":"Feb 8, 2016 1:09:27 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1549"},{"text":"//List also has foldRight and foldLeft as methods\n\nval l = (0 to 5).toList\n//l.foldLeft(0)(_+_)\n//l.foldLeft(0)((r,c) => r + c)\n//l.foldLeft(0)((s,_) => s + 1)\nl.foldLeft(List[Int]())((r,c) => c :: r)\n","dateUpdated":"Feb 11, 2016 11:13:55 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454962627073_101017166","id":"20160208-121707_1726718329","result":{"code":"SUCCESS","type":"TEXT","msg":"l: List[Int] = List(0, 1, 2, 3, 4, 5)\nres721: List[Int] = List(5, 4, 3, 2, 1, 0)\n"},"dateCreated":"Feb 8, 2016 12:17:07 PM","dateStarted":"Feb 11, 2016 11:10:32 AM","dateFinished":"Feb 11, 2016 11:10:32 AM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1550"},{"text":"def average(list: List[Double]): Double =\n  list.foldLeft(0.0)(_+_) / list.foldLeft(0.0)((r,c) => r+1)\n \nval r = scala.util.Random\nr.nextDouble //returns a value between 0.0 and 1.0\nval l2 = average((for {i <- (0 to 400)} yield r.nextDouble).toList)","dateUpdated":"Feb 11, 2016 2:39:08 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454962705671_-808438933","id":"20160208-121825_516823019","result":{"code":"SUCCESS","type":"TEXT","msg":"average: (list: List[Double])Double\nr: util.Random.type = scala.util.Random$@de68e58\nres727: Double = 0.5133105835076764\nl2: Double = 0.5194655379533586\n"},"dateCreated":"Feb 8, 2016 12:18:25 PM","dateStarted":"Feb 11, 2016 11:19:28 AM","dateFinished":"Feb 11, 2016 11:19:28 AM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1551"},{"text":"def contains[A](list: List[A], item: A): Boolean =\n  list.foldLeft(false)(_ || _ == item)\n  \n/*We choose an initial value of false. That is, we’ll assume the item is not in the list until we can prove otherwise. We use each of the two parameters exactly once and in the proper order, so we can use the ‘_’ shorthand in our function literal. That function literal returns the result so far (a Boolean) ORed with a comparison of the current item and the target value. If the target is ever found, the accumulator becomes true and stays true as foldLeft continues.*/\n","dateUpdated":"Feb 11, 2016 11:23:36 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454963928206_-50122922","id":"20160208-123848_1721153008","result":{"code":"SUCCESS","type":"TEXT","msg":"contains: [A](list: List[A], item: A)Boolean\n"},"dateCreated":"Feb 8, 2016 12:38:48 PM","dateStarted":"Feb 8, 2016 12:40:29 PM","dateFinished":"Feb 8, 2016 12:40:29 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1552"},{"text":"contains(List(1,2,3,4),4)","dateUpdated":"Feb 11, 2016 12:23:44 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455215273985_790377341","id":"20160211-102753_767013960","result":{"code":"SUCCESS","type":"TEXT","msg":"res778: Boolean = true\n"},"dateCreated":"Feb 11, 2016 10:27:53 AM","dateStarted":"Feb 11, 2016 12:23:44 PM","dateFinished":"Feb 11, 2016 12:23:44 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1553"},{"text":"def last[A](list: List[A]): A = list.foldLeft[A](list.head)((_, c) => c)\n\n//When it gets to the end of the list, the accumulator holds the last item. We don’t use the accumulator value in the function literal, so it gets parameter name ‘_’","dateUpdated":"Feb 11, 2016 11:30:39 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454963174267_1409508781","id":"20160208-122614_521577748","result":{"code":"SUCCESS","type":"TEXT","msg":"last: [A](list: List[A])A\n"},"dateCreated":"Feb 8, 2016 12:26:14 PM","dateStarted":"Feb 8, 2016 12:36:34 PM","dateFinished":"Feb 8, 2016 12:36:34 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1554"},{"text":"last(List(1,2,3,4))\n//List(1,2,3,4).head // hint- use head","dateUpdated":"Feb 11, 2016 12:23:33 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455215206841_695821056","id":"20160211-102646_2104497785","result":{"code":"SUCCESS","type":"TEXT","msg":"res775: Int = 4\n"},"dateCreated":"Feb 11, 2016 10:26:46 AM","dateStarted":"Feb 11, 2016 12:23:33 PM","dateFinished":"Feb 11, 2016 12:23:33 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1555"},{"text":"def penultimate[A](list: List[A]): A = \n  list.foldLeft( (list.head, list.tail.head) )((r, c) => (r._2, c) )._1\n\n/*This one is like the function ‘last’, but instead of keeping just the current item it keeps a Pair containing the previous and current items. When foldLeft completes, its result is a Pair containing the next-to-last and last items. The “_1” method returns just the penultimate item. You can use a similar idea to implement a more efficient average.*/ ","dateUpdated":"Feb 11, 2016 11:35:35 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454963794642_454851525","id":"20160208-123634_881660445","result":{"code":"SUCCESS","type":"TEXT","msg":"penultimate: [A](list: List[A])A\n"},"dateCreated":"Feb 8, 2016 12:36:34 PM","dateStarted":"Feb 8, 2016 12:36:53 PM","dateFinished":"Feb 8, 2016 12:36:53 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1556"},{"text":"// List(1,2,3,4).tail.head // hint- use (list.head, list.tail.head)  as the initial value\n// val a = (2,3)\n// a._1\npenultimate(List(1,2,3,4))","dateUpdated":"Feb 11, 2016 2:38:50 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":false},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455214976986_-1737467261","id":"20160211-102256_1933294188","result":{"code":"SUCCESS","type":"TEXT","msg":"res773: Int = 3\n"},"dateCreated":"Feb 11, 2016 10:22:56 AM","dateStarted":"Feb 11, 2016 12:23:33 PM","dateFinished":"Feb 11, 2016 12:23:33 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1557"},{"text":"def average2(list: List[Double]): Double = \n  list match {\n    case Nil => Double.NaN\n    case head :: tail => tail.foldLeft((head,1.0)) ((avg, nxt) => ( (avg._1+(nxt/avg._2)) * avg._2/(avg._2+1), avg._2+1) )._1\n  }\n  \naverage2(List(1,2,3,4))","dateUpdated":"Feb 11, 2016 12:23:06 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454971337011_-783237921","id":"20160208-144217_940826772","result":{"code":"SUCCESS","type":"TEXT","msg":"average2: (list: List[Double])Double\nres766: Double = 2.5\n"},"dateCreated":"Feb 8, 2016 2:42:17 PM","dateStarted":"Feb 11, 2016 12:23:03 PM","dateFinished":"Feb 11, 2016 12:23:03 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1558"},{"text":"def kthLast[A](l: List[A], k: Int) = {\n \n  def getK[A](elt: A, cache: List[A]): List[A] = \n    if (cache.length == k) cache\n    else elt :: cache\n    \n  l.foldRight(List[A]())(getK) head \n}\n\nkthLast(l,2)","dateUpdated":"Feb 11, 2016 12:22:47 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454970822856_-1076336673","id":"20160208-143342_1039747908","result":{"code":"SUCCESS","type":"TEXT","msg":"warning: there were 1 feature warning(s); re-run with -feature for details\nkthLast: [A](l: List[A], k: Int)A\nres621: Int = 4\n"},"dateCreated":"Feb 8, 2016 2:33:42 PM","dateStarted":"Feb 8, 2016 2:35:27 PM","dateFinished":"Feb 8, 2016 2:35:28 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1559"},{"config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455230277753_-1056517989","id":"20160211-143757_551738695","dateCreated":"Feb 11, 2016 2:37:57 PM","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:1996","text":"//curly braces are ok for function literals\ndef mapViaFoldLeft[A,B](list: List[A], f: A => B): List[B] =\n  list.foldLeft(List[B]()) { (xs: List[B], x: A) =>  f(x) :: xs }.reverse\n\nval l = (0 to 5).toList\nmapViaFoldLeft(l,(a: Int) => a*2)","dateUpdated":"Feb 11, 2016 2:38:24 PM","dateFinished":"Feb 11, 2016 2:38:21 PM","dateStarted":"Feb 11, 2016 2:38:20 PM","result":{"code":"SUCCESS","type":"TEXT","msg":"mapViaFoldLeft: [A, B](list: List[A], f: A => B)List[B]\nl: List[Int] = List(0, 1, 2, 3, 4, 5)\nres891: List[Int] = List(0, 2, 4, 6, 8, 10)\n"}},{"text":"def unique[A](list: List[A]): List[A] =\n  list.foldLeft(List[A]()) { (r,c) =>\n    if (r.contains(c)) r else c :: r\n  }.reverse\n  \n/*As usual, we start with an empty list. foldLeft looks at each list item and if it’s already contained in the accumulator then then it stays as it is. If it’s not in the accumulator then it’s appended. This code bears a striking similarity to the ‘reverse’ function we wrote earlier except for the “if (r.contains(c)) r” part. Because of this, the foldLeft result is actually the original list with duplicates removed, but in reverse order. To keep the output in the same order as the input, we add the call to reverse.*/","dateUpdated":"Feb 11, 2016 2:38:48 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454964029731_717941508","id":"20160208-124029_121982303","result":{"code":"SUCCESS","type":"TEXT","msg":"unique: [A](list: List[A])List[A]\nres683: List[Int] = List(2, 3, 1, 4)\n"},"dateCreated":"Feb 8, 2016 12:40:29 PM","dateStarted":"Feb 11, 2016 10:21:19 AM","dateFinished":"Feb 11, 2016 10:21:19 AM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1560"},{"text":"unique(List(2,3,2,3,2,3,1,4))\nList(1,2,3).contains(2) //hint- use contains","dateUpdated":"Feb 11, 2016 10:22:44 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455214888983_-280731304","id":"20160211-102128_1947987443","result":{"code":"SUCCESS","type":"TEXT","msg":"res687: List[Int] = List(2, 3, 1, 4)\nres688: Boolean = true\n"},"dateCreated":"Feb 11, 2016 10:21:28 AM","dateStarted":"Feb 11, 2016 10:22:23 AM","dateFinished":"Feb 11, 2016 10:22:23 AM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1561"},{"text":"def double[A](list: List[A]): List[A] =\n  list.foldLeft(List[A]())((r,c) => c :: c :: r).reverse\n  \n/*See a pattern? When you use foldLeft to transform one list into another, you usually end up with the reverse of what you really want.\n\nAlternately, you could have used the foldRight method instead. This does the same thing as foldLeft, except it accumulates its result from back to front instead of front to back.*/\n\ndef double2[A](list: List[A]): List[A] =\n  list.foldRight(List[A]())((c,r) => c :: c :: r)","dateUpdated":"Feb 11, 2016 2:39:00 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454964355223_2139282734","id":"20160208-124555_847750294","result":{"code":"SUCCESS","type":"TEXT","msg":"double: [A](list: List[A])List[A]\ndouble2: [A](list: List[A])List[A]\n"},"dateCreated":"Feb 8, 2016 12:45:55 PM","dateStarted":"Feb 8, 2016 12:47:14 PM","dateFinished":"Feb 8, 2016 12:47:14 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1562"},{"text":"val l = List(1,2,3) ::: List(4,5,6)\nl.partition(_ > 2)","dateUpdated":"Feb 8, 2016 12:57:51 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454964889772_-102313620","id":"20160208-125449_1036014039","result":{"code":"SUCCESS","type":"TEXT","msg":"l: List[Int] = List(1, 2, 3, 4, 5, 6)\nres531: (List[Int], List[Int]) = (List(3, 4, 5, 6),List(1, 2))\n"},"dateCreated":"Feb 8, 2016 12:54:49 PM","dateStarted":"Feb 8, 2016 12:57:51 PM","dateFinished":"Feb 8, 2016 12:57:51 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1563"},{"text":"def stackSort[A <% Ordered[A]](list: List[A]): List[A] =\n  list.foldLeft(List[A]()) { (r,c) =>\n    val (front, back) = r.partition(_ > c)\n    front ::: c :: back\n  }\n\n\nval l = List(9,3,4,2,6,4,8,1,5,63)\nprintln(l.mkString(\",\"))\nprintln(stackSort(l).mkString(\",\"))\n\n/*This can be done as an insertion sort using the foldLeft API. First, the type parameter ensures that we have elements that can be arranged in order. We start, predictably, with an empty list as our initial accumulator. Then, for each item we assume the accumulator is in order (which it always will be), and use span to split it into two sub-lists: all already-sorted items less than the current item, and all already-sorted items greater than or equal to the current item. We put the current item in between these two and the accumulator remains sorted. This is, of course, not the fastest way to sort a list. But it’s a neat foldLeft trick.*/","dateUpdated":"Feb 11, 2016 2:38:54 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454964661194_2142004980","id":"20160208-125101_1064710465","result":{"code":"SUCCESS","type":"TEXT","msg":"stackSort: [A](list: List[A])(implicit evidence$1: A => Ordered[A])List[A]\nl: List[Int] = List(9, 3, 4, 2, 6, 4, 8, 1, 5, 63)\n9,3,4,2,6,4,8,1,5,63\n63,9,8,6,5,4,4,3,2,1\n"},"dateCreated":"Feb 8, 2016 12:51:01 PM","dateStarted":"Feb 8, 2016 12:58:01 PM","dateFinished":"Feb 8, 2016 12:58:01 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1564"},{"text":"","dateUpdated":"Feb 8, 2016 2:48:39 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454964918863_-1658961697","id":"20160208-125518_638343587","dateCreated":"Feb 8, 2016 12:55:18 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:1565"}],"name":"sfds-lab2","id":"2BB3QUSY3","angularObjects":{"2BBX9KVBV":[],"2B9T31FJZ":[],"2BC97GWDB":[],"2BBRY8E4A":[],"2BBJF778P":[],"2BADXE7AU":[],"2BCSZYWYA":[],"2BC6W6857":[],"2BBBV3PP8":[],"2B956YWNV":[],"2BB6YM4DJ":[],"2B92D2YFF":[],"2BBG6HC2F":[],"2BAQREC7J":[]},"config":{"looknfeel":"default"},"info":{}}