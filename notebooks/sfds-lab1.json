{"paragraphs":[{"text":"//Pascal's Triangle\ndef pascal(c: Int, r: Int): Int = {\n  if (c == 0 || r == 0 || r == c) 1\n  else pascal(c-1, r-1) + pascal(c, r-1)\n}\n","dateUpdated":"Feb 3, 2016 2:32:28 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454531177430_1842975106","id":"20160203-122617_1167396027","result":{"code":"SUCCESS","type":"TEXT","msg":"pascal: (c: Int, r: Int)Int\n"},"dateCreated":"Feb 3, 2016 12:26:17 PM","dateStarted":"Feb 3, 2016 1:57:38 PM","dateFinished":"Feb 3, 2016 1:57:38 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1238"},{"text":"//Partially Applied Functions\ndef renderRow(r: Int) = ((0 to r).map(pascal(_,r))  mkString \" \") + '\\n'\nrenderRow(5)","dateUpdated":"Feb 3, 2016 2:39:40 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454536978435_204880908","id":"20160203-140258_796592657","result":{"code":"SUCCESS","type":"TEXT","msg":"renderRow: (r: Int)String\nres94: String = \n\"1 5 10 10 5 1\n\"\n"},"dateCreated":"Feb 3, 2016 2:02:58 PM","dateStarted":"Feb 3, 2016 2:20:57 PM","dateFinished":"Feb 3, 2016 2:20:57 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1239"},{"text":"//The strictly functional approach.\n\n\nprint((0 to 10).map(row => renderRow(row) ).reduce(_+_))\n\n","dateUpdated":"Feb 3, 2016 2:43:25 PM","config":{"colWidth":6,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454537845867_1391332145","id":"20160203-141725_1208916703","result":{"code":"SUCCESS","type":"TEXT","msg":"1\n1 1\n1 2 1\n1 3 3 1\n1 4 6 4 1\n1 5 10 10 5 1\n1 6 15 20 15 6 1\n1 7 21 35 35 21 7 1\n1 8 28 56 70 56 28 8 1\n1 9 36 84 126 126 84 36 9 1\n1 10 45 120 210 252 210 120 45 10 1\n"},"dateCreated":"Feb 3, 2016 2:17:25 PM","dateStarted":"Feb 3, 2016 2:43:25 PM","dateFinished":"Feb 3, 2016 2:43:26 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1240"},{"text":"//Basic For loops in Scala\nfor (row <- 0 to 10) {\n  for (col <- 0 to row)\n    print(pascal(col, row) + \" \")\n  println()\n}","dateUpdated":"Feb 3, 2016 2:38:29 PM","config":{"colWidth":6,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454531204747_1289352087","id":"20160203-122644_2110020285","result":{"code":"SUCCESS","type":"TEXT","msg":"1 \n1 1 \n1 2 1 \n1 3 3 1 \n1 4 6 4 1 \n1 5 10 10 5 1 \n1 6 15 20 15 6 1 \n1 7 21 35 35 21 7 1 \n1 8 28 56 70 56 28 8 1 \n1 9 36 84 126 126 84 36 9 1 \n1 10 45 120 210 252 210 120 45 10 1 \n"},"dateCreated":"Feb 3, 2016 12:26:44 PM","dateStarted":"Feb 3, 2016 1:57:45 PM","dateFinished":"Feb 3, 2016 1:57:46 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1241"},{"text":"//Comprehensions compile to map/filter/flatMaps. A bit like Python generators- stay tuned for Streams!\nval tmp = for {\n  row <- 0 to 10\n  col <- 0 to row\n  if col % 2 == 0\n} yield col","dateUpdated":"Feb 4, 2016 9:53:39 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454539431469_650345681","id":"20160203-144351_177179344","result":{"code":"SUCCESS","type":"TEXT","msg":"tmp: scala.collection.immutable.IndexedSeq[Int] = Vector(0, 0, 0, 2, 0, 2, 0, 2, 4, 0, 2, 4, 0, 2, 4, 6, 0, 2, 4, 6, 0, 2, 4, 6, 8, 0, 2, 4, 6, 8, 0, 2, 4, 6, 8, 10)\n"},"dateCreated":"Feb 3, 2016 2:43:51 PM","dateStarted":"Feb 3, 2016 2:48:20 PM","dateFinished":"Feb 3, 2016 2:48:20 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1242"},{"text":"//For comprehensions are preferred\n\nfor {\n  row <- 0 to 10\n  col <- 0 to row\n} print(pascal(col, row) + \" \")","dateUpdated":"Feb 4, 2016 9:54:17 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454531390219_-1863186811","id":"20160203-122950_2130102360","result":{"code":"SUCCESS","type":"TEXT","msg":"1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 1 10 45 120 210 252 210 120 45 10 1 "},"dateCreated":"Feb 3, 2016 12:29:50 PM","dateStarted":"Feb 3, 2016 3:18:01 PM","dateFinished":"Feb 3, 2016 3:18:01 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1243"},{"text":"//Mid-Stream Variable Bindings\n\nfor {\n  row <- 0 to 10\n  rowString <- renderRow(row)\n} print(rowString)","dateUpdated":"Feb 4, 2016 9:54:13 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454538451153_-564087648","id":"20160203-142731_1392093722","result":{"code":"SUCCESS","type":"TEXT","msg":"1\n1 1\n1 2 1\n1 3 3 1\n1 4 6 4 1\n1 5 10 10 5 1\n1 6 15 20 15 6 1\n1 7 21 35 35 21 7 1\n1 8 28 56 70 56 28 8 1\n1 9 36 84 126 126 84 36 9 1\n1 10 45 120 210 252 210 120 45 10 1\n"},"dateCreated":"Feb 3, 2016 2:27:31 PM","dateStarted":"Feb 3, 2016 2:28:57 PM","dateFinished":"Feb 3, 2016 2:28:57 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1244"},{"text":"//Lists[Int], Seq[Int], Array[Int], Vector[Int]. Draw\nNil\nval a = 1 :: Nil\nval b = 2 :: a\nval c = 1 :: 2 :: 3 :: Nil","dateUpdated":"Feb 3, 2016 9:07:49 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454560439039_-1259284574","id":"20160203-203359_1055843056","result":{"code":"SUCCESS","type":"TEXT","msg":"res264: scala.collection.immutable.Nil.type = List()\na: List[Int] = List(1)\nb: List[Int] = List(2, 1)\nc: List[Int] = List(1, 2, 3)\n"},"dateCreated":"Feb 3, 2016 8:33:59 PM","dateStarted":"Feb 3, 2016 9:00:00 PM","dateFinished":"Feb 3, 2016 9:00:01 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1245"},{"text":"//Pattern Matching\ndef sum(l: List[Int]): Int = l match {\n  case Nil => 0\n  case x :: xs => x + sum(xs)\n}\n\nsum(List(1,2,3))","dateUpdated":"Feb 4, 2016 9:25:08 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454561867299_-1635178792","id":"20160203-205747_1615501245","result":{"code":"SUCCESS","type":"TEXT","msg":"sum: (l: List[Int])Int\nres303: Int = 6\n"},"dateCreated":"Feb 3, 2016 8:57:47 PM","dateStarted":"Feb 4, 2016 9:25:08 AM","dateFinished":"Feb 4, 2016 9:25:08 AM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1246"},{"text":"//Product\ndef product(ds: List[Int]): Int = ds match {\n  case Nil => 1\n  case 0 :: _ => 0\n  case x :: xs => x * product(xs)\n}","dateUpdated":"Feb 4, 2016 9:26:20 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454606702955_1334228302","id":"20160204-092502_851812390","result":{"code":"SUCCESS","type":"TEXT","msg":"product: (ds: List[Int])Int\n"},"dateCreated":"Feb 4, 2016 9:25:02 AM","dateStarted":"Feb 4, 2016 9:26:17 AM","dateFinished":"Feb 4, 2016 9:26:17 AM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1247"},{"text":"var a:List[Int] = Nil\nfor(i<- 10 to 1 by -1) a = i :: a\na","dateUpdated":"Feb 3, 2016 9:04:30 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454562051799_-1682393993","id":"20160203-210051_125488824","result":{"code":"SUCCESS","type":"TEXT","msg":"a: List[Int] = List()\nres276: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"},"dateCreated":"Feb 3, 2016 9:00:51 PM","dateStarted":"Feb 3, 2016 9:04:30 PM","dateFinished":"Feb 3, 2016 9:04:31 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1248"},{"text":"def build(n: Int, l: List[Int]): List[Int] = {\n    if (n == 0) l\n    else build(n-1, n::l)\n}\nbuild(10, Nil)\ndef factorial(n: Int) = product(build(n, Nil))\nfactorial(5)","dateUpdated":"Feb 4, 2016 9:31:05 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454562320454_-2078702329","id":"20160203-210520_658613031","result":{"code":"SUCCESS","type":"TEXT","msg":"build: (n: Int, l: List[Int])List[Int]\nres316: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nfactorial: (n: Int)Int\nres317: Int = 120\n"},"dateCreated":"Feb 3, 2016 9:05:20 PM","dateStarted":"Feb 4, 2016 9:30:48 AM","dateFinished":"Feb 4, 2016 9:30:48 AM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1249"},{"text":"List(1,2,3) match { case _ :: t => t } \n/*Here we’re using a variable pattern, _, which matches any expression. We could say x or foo instead of _, but we usually use _ to indicate a variable whose value we ignore in the result of the case. The _ variable pattern is treated somewhat specially in that it may be mentioned multiple times in the pattern to ignore multiple parts of the target.*/\n//List(1,2,3) match { case _ => 42 }\n//List(1,2,3) match { case Nil => 42 } \n//List(1,2,3) match { case h :: _  => h }\n/* Here we’re using a data constructor pattern in conjunction with variables to capture or bind a subexpression of the target.*/\n\n","dateUpdated":"Feb 4, 2016 9:40:43 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":false},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454606569174_680960775","id":"20160204-092249_1356009827","dateCreated":"Feb 4, 2016 9:22:49 AM","dateStarted":"Feb 4, 2016 9:40:29 AM","dateFinished":"Feb 4, 2016 9:40:30 AM","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1250"},{"text":"//What value will this expression return \nval x = List(1,2,3,4,5) match {\n  case x :: 2 :: 4 :: _ => x\n  case Nil => 42\n  case x :: y :: 3 :: 4 :: _ =>x+y\n  case h :: t => h + sum(t)\n  case _ => 101\n}","dateUpdated":"Feb 4, 2016 9:42:15 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454607667478_-995799002","id":"20160204-094107_900342421","dateCreated":"Feb 4, 2016 9:41:07 AM","dateStarted":"Feb 4, 2016 9:42:15 AM","dateFinished":"Feb 4, 2016 9:42:16 AM","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1251"},{"text":"val a = build(10, Nil)\na.head\na.tail\na.take(3)\na.drop(3)\na.splitAt(3)\na","dateUpdated":"Feb 3, 2016 9:07:26 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454562220675_-702424865","id":"20160203-210340_1626220473","result":{"code":"SUCCESS","type":"TEXT","msg":"res284: Int = 1\nres285: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10)\nres286: List[Int] = List(1, 2, 3)\nres287: List[Int] = List(4, 5, 6, 7, 8, 9, 10)\nres288: (List[Int], List[Int]) = (List(1, 2, 3),List(4, 5, 6, 7, 8, 9, 10))\nres289: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"},"dateCreated":"Feb 3, 2016 9:03:40 PM","dateStarted":"Feb 3, 2016 9:04:41 PM","dateFinished":"Feb 3, 2016 9:04:42 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1252"},{"text":"/*Note that this definition only copies values until the first list is exhausted, so its runtime and memory usage are determined only by the length of a1. The remaining list then just points to a2. If we were to implement this same function for two arrays, we’d be forced to copy all the elements in both arrays into the result. In this case, the immutable linked list is much more efficient than an array */\n\ndef append[A](a1: List[A], a2: List[A]): List[A] =\n  a1 match {\n    case Nil => a2\n    case h :: t => h :: append(t, a2)\n}\n\nappend(List(1,2,3), List(4,5,6))","dateUpdated":"Feb 4, 2016 9:52:02 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":false},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454607821635_1030289229","id":"20160204-094341_1720714952","result":{"code":"SUCCESS","type":"TEXT","msg":"append: [A](a1: List[A], a2: List[A])List[A]\nres343: List[Int] = List(1, 2, 3, 4, 5, 6)\n"},"dateCreated":"Feb 4, 2016 9:43:41 AM","dateStarted":"Feb 4, 2016 9:44:24 AM","dateFinished":"Feb 4, 2016 9:44:25 AM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1253"},{"text":"//Pattern matching\ndef fizzBuzz(x: Int) = (x % 3, x % 5) match {\n  case (0, 0) => \"FizzBuzz\"\n  case (0, _) => \"Fizz\"\n  case (_, 0) => \"Buzz\"\n  case _ => x.toString\n}\n(1 to 20) map fizzBuzz","dateUpdated":"Feb 3, 2016 8:57:26 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454559180551_1881641290","id":"20160203-201300_1825192722","result":{"code":"SUCCESS","type":"TEXT","msg":"fizzBuzz: (x: Int)String\nres208: scala.collection.immutable.IndexedSeq[String] = Vector(1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, 17, Fizz, 19, Buzz)\n"},"dateCreated":"Feb 3, 2016 8:13:00 PM","dateStarted":"Feb 3, 2016 8:33:12 PM","dateFinished":"Feb 3, 2016 8:33:13 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1254"},{"text":"def countChange(money: Int, coins: List[Int]): Int = {\n  if (money == 0) 1\n  else if (money < 0 || coins.isEmpty) 0\n  else if (money <= 0 && !coins.isEmpty) 0\n  else countChange(money, coins.tail) + countChange(money - coins.head, coins)\n}\ncountChange(20, List(10,5))","dateUpdated":"Feb 4, 2016 10:21:00 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454560181003_-1821385748","id":"20160203-202941_1022615758","result":{"code":"SUCCESS","type":"TEXT","msg":"countChange: (money: Int, coins: List[Int])Int\nres210: Int = 3\n"},"dateCreated":"Feb 3, 2016 8:29:41 PM","dateStarted":"Feb 3, 2016 8:34:11 PM","dateFinished":"Feb 3, 2016 8:34:12 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1255"},{"text":"def countChange2(money: Int, coins: List[Int]): Int = (money, coins) match {\n   case (0, _) => 1\n   case (m, _) if m < 0 => 0\n   case (_, c) if c.isEmpty => 0\n   case (m, c) => countChange2(m - c.head, c) + countChange2(m, c.tail) \n}\ncountChange2(20, List(10,5))","dateUpdated":"Feb 4, 2016 10:21:01 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454560172291_1530546669","id":"20160203-202932_1478356683","result":{"code":"SUCCESS","type":"TEXT","msg":"countChange2: (money: Int, coins: List[Int])Int\nres347: Int = 3\n"},"dateCreated":"Feb 3, 2016 8:29:32 PM","dateStarted":"Feb 4, 2016 10:18:52 AM","dateFinished":"Feb 4, 2016 10:18:53 AM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1256","focus":true},{"text":"//Jake's solution\ndef pascal(i:Int,j:Int): Int={\n    if(i==0 || i==j||j==0){1}\n    else{\n        pascal(i-1,j)+pascal(i-1,j-1)\n    }\n}\n\ndef showTriangle(row:Int): Unit={\n//establish the base case print\n    if(row==0){println(pascal(0,0))}\n\n//create array of tuples and print recursively\n    else{\n        showTriangle(row-1)\n        val x = (row,0 to row toArray)\n        println(x._2.map((x._1,_)).map(l=>pascal(l._1,l._2)).deep.mkString(\" \"))\n    }\n}\nshowTriangle(10)","dateUpdated":"Feb 3, 2016 8:35:55 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454548954300_-74117958","id":"20160203-172234_204327266","dateCreated":"Feb 3, 2016 5:22:34 PM","dateStarted":"Feb 3, 2016 8:35:55 PM","dateFinished":"Feb 3, 2016 8:35:57 PM","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1258"},{"text":"//Ben's solution\ndef binom(n: Int, k: Int): Int = {\n    if (k==0) 1\n    else (1 to k).map(x => (n + 1.0 - x) / x).reduceLeft(_ * _).toInt\n}\n\ndef pascal(i: Int) {\n    val ns = 0 to (i-1)\n    val kss = ns.map(0 to _)\n    \n    for ((n, ks) <- ns zip kss) {\n        ks.map(k => binom(n,k)).map(x => x.toString + ' ').map(print)\n        println\n    }\n}\n\npascal(10)","dateUpdated":"Feb 3, 2016 8:35:35 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454538935994_-734270376","id":"20160203-143535_72793282","dateCreated":"Feb 3, 2016 2:35:35 PM","dateStarted":"Feb 3, 2016 8:35:35 PM","dateFinished":"Feb 3, 2016 8:35:36 PM","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1259"},{"text":"//Using types to understand code\ndef binom(n: Int, k: Int): Int = {\n    if (k==0) 1\n    else (1 to k).map(x => (n + 1.0 - x) / x)\n}","dateUpdated":"Feb 3, 2016 8:35:00 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454539965553_323102800","id":"20160203-145245_519872942","dateCreated":"Feb 3, 2016 2:52:45 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:1260"},{"text":"binom(40,20)","dateUpdated":"Feb 3, 2016 7:49:35 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454549599624_-2143407577","id":"20160203-173319_1810877009","dateCreated":"Feb 3, 2016 5:33:19 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:1261"},{"text":"pascal(40,20)","dateUpdated":"Feb 3, 2016 7:49:35 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454557754306_-527923411","id":"20160203-194914_1797358349","dateCreated":"Feb 3, 2016 7:49:14 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:1262"},{"text":"def fib (n: Long): Long = n match {\n  case 0 | 1 => n\n  case _ => fib( n - 2) + fib( n - 1 )\n}\n\ndef fib1 (n: Long): Long = {\n  def loop(current: Long, next: => Long, iteration: Long): Long = {\n    if (n == iteration) \n      current\n    else\n      loop(next, current + next, iteration + 1)\n  }\n  loop(0, 1, 0)\n}\n\nfib1(30)","dateUpdated":"Feb 3, 2016 8:36:36 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454553397452_-112582825","id":"20160203-183637_894734763","result":{"code":"SUCCESS","type":"TEXT","msg":"fib: (n: Long)Long\nfib1: (n: Long)Long\nres178: Long = 832040\n"},"dateCreated":"Feb 3, 2016 6:36:37 PM","dateStarted":"Feb 3, 2016 7:48:09 PM","dateFinished":"Feb 3, 2016 7:48:09 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1263"},{"text":"//Row by row generation is asymptotically suboptimal. What about a dynamic programming approach?\ndef pascal3(col: Long, row: Long): Long = {\n  (col, row) match {\n    case (c, r) if (c == 0) || (c == r) => 1\n    case p => find(List(p), Map())\n  }\n}","dateUpdated":"Feb 3, 2016 8:09:22 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454558737818_-430776220","id":"20160203-200537_547967477","dateCreated":"Feb 3, 2016 8:05:37 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:1264"},{"text":"var colors = Map(\n  \"red\" -> \"#FF0000\",\n  \"azure\" -> \"#F0FFFF\",\n  \"peru\" -> \"#CD853F\")\ncolors += (\"indigo\" -> \"#4B0082\")\nprintln(colors.size)","dateUpdated":"Feb 3, 2016 8:18:25 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454559475144_-85226856","id":"20160203-201755_373416150","result":{"code":"SUCCESS","type":"TEXT","msg":"colors: scala.collection.immutable.Map[String,String] = Map(red -> #FF0000, azure -> #F0FFFF, peru -> #CD853F)\n4\n"},"dateCreated":"Feb 3, 2016 8:17:55 PM","dateStarted":"Feb 3, 2016 8:18:25 PM","dateFinished":"Feb 3, 2016 8:18:26 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1265"},{"text":"//Memoized version\n\ntype Point = (Long, Long)\ntype Points = List[Point]\ntype Triangle = Map[Point,Long]\n  \ndef above(p: Point) = (p._1, p._2 - 1)\ndef aboveLeft(p: Point) = (p._1 - 1, p._2 - 1)\ndef find(ps: Points, t: Triangle): Long = ps match {\n  case (p :: Nil) if t contains p => t(p) // Found the ultimate goal\n  case (p :: rest) if t contains p => find(rest, t) // Found an intermediate point: pop the stack and carry on\n  case ((c, r) :: _) if (c == 0) || (c == r) => find(ps, t + ((c,r) -> 1)) // Hit a triangle edge, add it to the triangle\n  case (p :: _) if t contains aboveLeft(p) => \n    if (t contains above(p)) // Triangle contains (c - 1, r - 1)...\n      find(ps, t + (p -> (t(aboveLeft(p)) + t(above(p))))) // And it contains (c, r - 1)!  Add to the triangle\n    else\n      find(above(p) :: ps, t) // Does not contain(c, r -1).  So find that\n  case (p :: _) => find(aboveLeft(p) :: ps, t) // If we get here, we don't have (c - 1, r - 1).  Find that.\n}\n\ndef pascal3(col: Long, row: Long): Long = {\n  require(col >= 0 && row >= 0 && col <= row)\n  (col, row) match {\n    case (c, r) if (c == 0) || (c == r) => 1\n    case p => find(List(p), Map())\n  }\n}\npascal(20,40)","dateUpdated":"Feb 3, 2016 8:17:02 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454553404075_59800006","id":"20160203-183644_42026803","result":{"code":"SUCCESS","type":"TEXT","msg":"defined type alias Point\ndefined type alias Points\ndefined type alias Triangle\nabove: (p: (Long, Long))(Long, Long)\naboveLeft: (p: (Long, Long))(Long, Long)\nfind: (ps: Points, t: Triangle)Long\npascal3: (col: Long, row: Long)Long\nres194: Long = 137846528820\n"},"dateCreated":"Feb 3, 2016 6:36:44 PM","dateStarted":"Feb 3, 2016 8:17:02 PM","dateFinished":"Feb 3, 2016 8:17:03 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1267"},{"config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454609808173_1181313825","id":"20160204-101648_1574909923","dateCreated":"Feb 4, 2016 10:16:48 AM","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:1812","text":"println(balance(\"([{()}]){{{[]}}}\".toList)) ","dateUpdated":"Feb 4, 2016 10:17:10 AM","dateFinished":"Feb 4, 2016 10:17:11 AM","dateStarted":"Feb 4, 2016 10:17:10 AM","result":{"code":"SUCCESS","type":"TEXT","msg":"true\n"}},{"text":"//Curried version w/ pattern matching. Jason will discuss currying on Tuesday.\ndef pascal2(r: Int)(c: Int): Int = (r, c) match {\n  case (0, 0) => 1\n  case (_, 0) => 1\n  case (0, _) => 1\n  case (r, c)  if (r == c) => 1\n  case (r, c) => pascal2(r-1)(c-1) + pascal2(r-1)(c)\n}\n\ndef showTriangle(rows: Int) = {\n  val lines = for {\n    r <- 0 until rows\n  } yield (0 to r) map pascal2(r) mkString \" \"\n  \"\\n\" + (lines mkString \"\\n\")\n}\nprintln(showTriangle(10)) ","dateUpdated":"Feb 4, 2016 10:17:17 AM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1454532466909_-1126121242","id":"20160203-124746_2143629811","dateCreated":"Feb 3, 2016 12:47:46 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:1269"}],"name":"sfds-lab1","id":"2BACEW3MH","angularObjects":{"2BBX9KVBV":[],"2B9T31FJZ":[],"2BC97GWDB":[],"2BBRY8E4A":[],"2BBJF778P":[],"2BADXE7AU":[],"2BCSZYWYA":[],"2BC6W6857":[],"2BBBV3PP8":[],"2B956YWNV":[],"2BB6YM4DJ":[],"2B92D2YFF":[],"2BBG6HC2F":[],"2BAQREC7J":[]},"config":{"looknfeel":"default"},"info":{}}