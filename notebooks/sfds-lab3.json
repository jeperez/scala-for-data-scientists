{"paragraphs":[{"text":"trait Monoid[A] {\n  def op(a1: A, a2: A): A\n  def zero: A\n}\n\nval dblMonoid: Monoid[Double] = new Monoid[Double] {\n  def op(x: Double, y: Double) = x + y\n  val zero: Double = 0.0\n}\n\n// There is a choice of implementation here as well.\n// Do we implement it as `f compose g` or `f andThen g`? We have to pick one.\ndef endoMonoid[A]: Monoid[A => A] = new Monoid[A => A] {\n  def op(f: A => A, g: A => A) = f compose g\n  val zero = (a: A) => a\n}","dateUpdated":"Feb 11, 2016 2:52:22 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455228565352_2063160721","id":"20160211-140925_697433061","result":{"code":"SUCCESS","type":"TEXT","msg":"defined trait Monoid\ndblMonoid: Monoid[Double] = $iwC$$iwC$$iwC$$iwC$$iwC$$iwC$$iwC$$iwC$$iwC$$anon$1@577f252\nendoMonoid: [A]=> Monoid[A => A]\ndual: [A](m: Monoid[A])Monoid[A]\nfoldMap: [A, B](as: List[A], m: Monoid[B])(f: A => B)B\nfoldRight: [A, B](as: List[A])(z: B)(f: (A, B) => B)B\nfoldLeft: [A, B](as: List[A])(z: B)(f: (B, A) => B)B\nwarning: there were 1 feature warning(s); re-run with -feature for details\ndefined trait Foldable\nproductMonoid: [A, B](A: Monoid[A], B: Monoid[B])Monoid[(A, B)]\ndefined class ListFoldable\n"},"dateCreated":"Feb 11, 2016 2:09:25 PM","dateStarted":"Feb 11, 2016 2:09:52 PM","dateFinished":"Feb 11, 2016 2:09:53 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:359"},{"text":"// We can get the dual of any monoid just by flipping the `op`.\ndef dual[A](m: Monoid[A]): Monoid[A] = new Monoid[A] {\n  def op(x: A, y: A): A = m.op(y, x)\n  val zero = m.zero\n}","dateUpdated":"Feb 11, 2016 2:52:46 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455231140784_264921507","id":"20160211-145220_93109414","dateCreated":"Feb 11, 2016 2:52:20 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:360"},{"text":"def productMonoid[A,B](A: Monoid[A], B: Monoid[B]): Monoid[(A, B)] =\n  new Monoid[(A, B)] {\n    def op(x: (A, B), y: (A, B)) =\n      (A.op(x._1, y._1), B.op(x._2, y._2))\n    val zero = (A.zero, B.zero)\n  }","dateUpdated":"Feb 11, 2016 2:53:40 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455231191300_-526060935","id":"20160211-145311_819284673","dateCreated":"Feb 11, 2016 2:53:11 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:361"},{"text":"// Notice that this function does not require the use of `map` at all.\n// All we need is `foldLeft`.\ndef foldMap[A, B](as: List[A], m: Monoid[B])(f: A => B): B =\n  as.foldLeft(m.zero)((b, a) => m.op(b, f(a)))\n\n// The function type `(A, B) => B`, when curried, is `A => (B => B)`.\n// And of course, `B => B` is a monoid for any `B` (via function composition).\ndef foldRight[A, B](as: List[A])(z: B)(f: (A, B) => B): B =\n  foldMap(as, endoMonoid[B])(f.curried)(z)\n\n// Folding to the left is the same except we flip the arguments to\n// the function `f` to put the `B` on the correct side.\n// Then we have to also \"flip\" the monoid so that it operates from left to right.\ndef foldLeft[A, B](as: List[A])(z: B)(f: (B, A) => B): B =\n  foldMap(as, dual(endoMonoid[B]))(a => b => f(b, a))(z)\n","dateUpdated":"Feb 11, 2016 2:53:40 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455231154423_-450326698","id":"20160211-145234_1837444531","dateCreated":"Feb 11, 2016 2:52:34 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:362"},{"text":"trait Foldable[F[_]] {\n  def foldRight[A,B](as: F[A])(z: B)(f: (A, B) => B): B =\n    foldMap(as)(f.curried)(endoMonoid[B])(z)\n\n  def foldMap[A, B](as: F[A])(f: A => B)(mb: Monoid[B]): B =\n    foldRight(as)(mb.zero)((a, b) => mb.op(f(a), b))\n}","dateUpdated":"Feb 11, 2016 2:53:40 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455231173776_259196246","id":"20160211-145253_50392648","dateCreated":"Feb 11, 2016 2:52:53 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:363"},{"text":"class ListFoldable extends Foldable[List] {\n  override def foldRight[A, B](as: List[A])(z: B)(f: (A, B) => B) =\n    as.foldRight(z)(f)\n  override def foldMap[A, B](as: List[A])(f: A => B)(mb: Monoid[B]): B =\n    foldLeft(as)(mb.zero)((b, a) => mb.op(b, f(a)))\n}","dateUpdated":"Feb 11, 2016 2:53:40 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455231208567_127474205","id":"20160211-145328_1734803089","dateCreated":"Feb 11, 2016 2:53:28 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:364"},{"text":"val pm = productMonoid(dblMonoid, dblMonoid)\nval lf = new ListFoldable\nval av = lf.foldMap(List(1.0,2.0,3.0,4.0))(a => (1.0,a))(pm)\nav._1/av._2","dateUpdated":"Feb 11, 2016 2:11:21 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455228581863_105573642","id":"20160211-140941_262536063","result":{"code":"SUCCESS","type":"TEXT","msg":"pm: Monoid[(Double, Double)] = $iwC$$iwC$$iwC$$iwC$$iwC$$iwC$$iwC$$iwC$$iwC$$anon$1@2e8b6fcc\nlf: ListFoldable = $iwC$$iwC$$iwC$ListFoldable@681f5769\nav: (Double, Double) = (4.0,10.0)\nres854: Double = 0.4\n"},"dateCreated":"Feb 11, 2016 2:09:41 PM","dateStarted":"Feb 11, 2016 2:11:21 PM","dateFinished":"Feb 11, 2016 2:11:22 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:365"},{"text":"/* \nhttp://stackoverflow.com/questions/7533837/explanation-of-combinators-for-the-working-man\nhttp://www.scala-lang.org/docu/files/collections-api/collections.html\n\nfoldLeft and foldRight you've seen. Interestingly, the following functional combinators can be written on top of a fold:\n\n\ndef map[B](f: (A) => B): CC[B] //map returns a collection with every element transformed by f\n\n\ndef foreach[U](f: Elem => U): Unit //foreach executes f over each element in a collection.\n\ndef forall(p: (A) => Boolean): Boolean //true if p(x) holds for all elements x of xs, false otherwise.\n\ndef filter(p: (A) => Boolean): Iterable[A] //filter returns a collection with all elements matching the predicate function\n\n\ndef partition(p: (A) ⇒ Boolean): (Iterable[A], Iterable[A]) //partition splits a collection into two halves based on a predicate function\n\n\ndef groupBy[K](f: (A) => K): Map[K, Iterable[A]] //groupBy splits a collection into two halves based on a predicate function\n\n\ndef find (p: (A) => Boolean): Option[A] //find returns the first element that matches the predicate function. More on Option later.\n\n\n\n#take and drop. takes/drops the first i elements.\n\n\n#takeWhile and dropWhile. takes/drops the first elements that match a predicate function. For example, if we `dropWhile` odd numbers from our list of numbers, 1 gets dropped (but not 3 which is “shielded” by 2).\n\n\n#flatten collapses one level of nested structure.\n\n\nflatMap[B](f: A => Iterable[B]): Iterable[B] //flatMap is a frequently used combinator that combines mapping and flattening. flatMap takes a function that works on the nested lists and then concatenates the results back together.\n\n\nWhat are more examples of combinators?\n\nFar too many to list! Both of those transform a function that describes behavior on a single value into a function that describes behavior on an entire collection. You can also have functions that transform only other functions, such as composing them end-to-end, or splitting and recombining arguments. You can have combinators that turn single-step operations into recursive operations that produce or consume collections. Or all kinds of other things, really.\n\n---\n\nHow do I design effective combinators?\n\nWe will see some examples in terms of error handling and random number generation.\n\nFirst, think about what operations make sense on whatever data your program uses. Then think about how those operations can be meaningfully combined in generic ways, as well as how operations can be broken down into smaller pieces that are connected back together. The main thing is to work with transformations and operations, not direct actions. When you have a function that just does some complicated bit of functionality in an opaque way and only spits out some sort of pre-digested result, there's not much you can do with that. Leave the final results to the code that uses the combinators--you want things that take you from point A to point B, not things that expect to be the beginning or end of a process.\n\n*/","dateUpdated":"Feb 11, 2016 5:56:11 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455231092026_-1437485107","id":"20160211-145132_295257490","dateCreated":"Feb 11, 2016 2:51:32 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:366"},{"text":"\n\n!scala\nval chars = 'a' to 'z'\nval perms = chars flatMap { a =>\n  chars flatMap { b =>\n    if (a != b) Seq(\"%c%c\".format(a, b))\n    else Seq()\n  }\n}\n\n\nval perms = for {\n  a <- chars\n  b <- chars\n  if a != b\n} yield \"%c%c\".format(a, b)\n","dateUpdated":"Feb 11, 2016 3:43:56 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455067684865_1421224837","id":"20160209-172804_917850274","dateCreated":"Feb 9, 2016 5:28:04 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:367"},{"text":"//a very common pattern. essentially the combinator assembly code version of an iterated for loop\n\nval N = 5\nval M = 3\nval listA = (1 to N)\nval listB = (1 to M)\n\nlistA flatMap (a => listB map (b => (a, b)))","dateUpdated":"Feb 11, 2016 10:45:20 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455237530498_1725175970","id":"20160211-163850_1684039810","result":{"code":"SUCCESS","type":"TEXT","msg":"N: Int = 5\nM: Int = 3\nlistA: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5)\nlistB: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3)\nres901: scala.collection.immutable.IndexedSeq[(Int, Int)] = Vector((1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1), (3,2), (3,3), (4,1), (4,2), (4,3), (5,1), (5,2), (5,3))\n"},"dateCreated":"Feb 11, 2016 4:38:50 PM","dateStarted":"Feb 11, 2016 10:44:05 PM","dateFinished":"Feb 11, 2016 10:44:05 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:368"},{"config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455260158100_1958816854","id":"20160211-225558_1650422599","dateCreated":"Feb 11, 2016 10:55:58 PM","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:625","text":"for {\n    a <- listA\n    b <- listB\n} yield (a, b)","dateUpdated":"Feb 11, 2016 10:56:48 PM","dateFinished":"Feb 11, 2016 10:56:48 PM","dateStarted":"Feb 11, 2016 10:56:48 PM","result":{"code":"SUCCESS","type":"TEXT","msg":"res903: scala.collection.immutable.IndexedSeq[(Int, Int)] = Vector((1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1), (3,2), (3,3), (4,1), (4,2), (4,3), (5,1), (5,2), (5,3))\n"}},{"text":"def isPrime(n: Int): Boolean = (2 until n) forall (d => n % d != 0)\nisPrime(17)","dateUpdated":"Feb 11, 2016 4:42:00 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455237710746_-2078422653","id":"20160211-164150_1819093337","result":{"code":"SUCCESS","type":"TEXT","msg":"isPrime: (n: Int)Boolean\nres895: Boolean = true\n"},"dateCreated":"Feb 11, 2016 4:41:50 PM","dateStarted":"Feb 11, 2016 4:42:00 PM","dateFinished":"Feb 11, 2016 4:42:00 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:369"},{"text":"//effective Scala style\n\nval votes = Seq((\"a\", 1), (\"b\", 4), (\"a\", 10), (\"a\", 1), (\"c\", 10))\nval orderedVotes = votes\n  .groupBy(_._1)\n  .map { case (which, counts) =>\n    (which, counts.foldLeft(0)(_ + _._2))\n  }.toSeq\n  .sortBy(_._2)\n  .reverse\n\nval votesByLet = votes groupBy { case (let, _) => let }\nval sumByLet = votesByLet map { case (let, counts) =>\n  val countsOnly = counts map { case (_, count) => count }\n  (let, countsOnly.sum)\n}\nval orderedVotes = sumByLet.toSeq\n  .sortBy { case (_, count) => count }\n  .reverse","dateUpdated":"Feb 11, 2016 3:44:34 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455234249900_1512301511","id":"20160211-154409_1867985791","dateCreated":"Feb 11, 2016 3:44:09 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:370"},{"text":"def snakeString(s: String): String = {\n\n\tdef foo(x:(Char,Int)) = (x._1,x._2%4)\n\n\tval rows = s.toCharArray.zipWithIndex.map(foo).groupBy {\n\t\tcase (x,0) => \"middle\"\n\t\tcase (x,1) => \"upper\"\n\t\tcase (x,2) => \"middle\"\n\t\tcase (x,3) => \"lower\"\n\t}  \n\n\trows.valuesIterator.toList.reverse.flatten.map(_._1).mkString\n}\n\n\nprintln(snakeString(\"Hello World!\")) ","dateUpdated":"Feb 11, 2016 5:13:33 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455239580276_814490942","id":"20160211-171300_1351714643","result":{"code":"SUCCESS","type":"TEXT","msg":"snakeString: (s: String)String\ne lHloWrdlo!\n"},"dateCreated":"Feb 11, 2016 5:13:00 PM","dateStarted":"Feb 11, 2016 5:13:33 PM","dateFinished":"Feb 11, 2016 5:13:33 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:371"},{"text":"def queens(n: Int): Set[List[Int]] = {\n    def placeQueens(k: Int): Set[List[Int]] = \n        if (k == 0) Set(List())\n        else\n            for {\n                queens <- placeQueens(k - 1)\n                col <- 0 until n\n                if isSafe(col, queens)\n            } yield col::queens\n    placeQueens(n)\n}\n\ndef isSafe(col: Int, queens: List[Int]): Boolean = {\n    val row = queens.length\n    val queensWithRow = (row - 1 to 0 by -1) zip queens\n    queensWithRow forall {\n    case (r, c) => col != c && math.abs(col - c) != row - r\n    }\n}\n\ndef showQueens(queens: List[Int]) = {\n    val lines = for (col <- queens.reverse)\n                yield Vector.fill(queens.length)(\"* \").updated(col, \"X \").mkString\n    \"\\n\" + (lines mkString \"\\n\")\n}\n\ndef main(args: Array[String]) {\n    println((queens(8) take(3) map showQueens) mkString \"\\n\") //print 3 solns\n}","dateUpdated":"Feb 11, 2016 4:46:10 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455237957710_-1917063435","id":"20160211-164557_1728710751","dateCreated":"Feb 11, 2016 4:45:57 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:372"},{"text":"def checkX(board: List[(Int,Int)], next: (Int,Int)): Boolean = {\n\tdef check(b: Boolean, tuple: (Int,Int)) = \n\t\t{ b && ((tuple._1 / 9 == next._1 / 9 && tuple._2 != next._2) || tuple._1 / 9 != next._1 / 9) }\n\tboard.foldLeft(true)(check)      \n}\n\ndef checkY(board: List[(Int,Int)], next: (Int,Int)): Boolean = {\n\tdef check(b: Boolean, tuple: (Int,Int)) = \n\t\t{ b && ((tuple._1 % 9 == next._1 % 9 && tuple._2 != next._2) || tuple._1 % 9 != next._1 % 9) }\n\tboard.foldLeft(true)(check)    \n}\n\ndef checkT(board: List[(Int,Int)], next: (Int,Int)): Boolean = {\n\tdef tile(index: Int): Int = {\n\t\tval y: Int = index % 9\n\t\tval x: Int = index / 9\n\t\t(x,y) match {\n\t\t\tcase _ if (0 to 2 contains y) && (0 to 2 contains x) => 0\n\t\t\tcase _ if (3 to 5 contains y) && (0 to 2 contains x) => 1\n\t\t\tcase _ if (6 to 8 contains y) && (0 to 2 contains x) => 2\n\t\t\tcase _ if (0 to 2 contains y) && (3 to 5 contains x) => 3\n\t\t\tcase _ if (3 to 5 contains y) && (3 to 5 contains x) => 4\n\t\t\tcase _ if (6 to 8 contains y) && (3 to 5 contains x) => 5\n\t\t\tcase _ if (0 to 2 contains y) && (6 to 8 contains x) => 6\n\t\t\tcase _ if (3 to 5 contains y) && (6 to 8 contains x) => 7\n\t\t\tcase _ if (6 to 8 contains y) && (6 to 8 contains x) => 8\n\t\t}\n\t} \n\tdef check(b: Boolean, tuple: (Int,Int)) = \n\t\t{ b && ((tile(tuple._1) == tile(next._1) && tuple._2 != next._2) || tile(tuple._1) != tile(next._1)) }\n\tboard.foldLeft(true)(check)    \n}\n\ndef notPlayed(board: List[(Int,Int)], index: Int): Boolean = {\n\t!(board map {x => x._1} contains index)\n}\n\ndef isLegal(board: List[(Int,Int)], next: (Int,Int)): Boolean = {\n\tcheckX(board, next) && checkY(board, next) && checkT(board, next) \n}\n\n//generate all possible valid Sudoku solutions (compare 16-02)\n//this is for reference only (there are 6,670,903,752,021,072,936,960 solutions, see Felgenhauer and Jarvis)\ndef sudokuAll(index: Int): Set[List[(Int,Int)]] = {\n\tif (index == -1) Set(List())\n\telse\n\t\tfor {\n\t\t\tboard <- sudokuAll(index-1)\n\t\t\tk <- 0 until 9\n\t\t\tif isLegal(board, (index,k))\n\t\t} yield (index,k)::board\n}\n\ndef sudokuSolve(initial: List[(Int,Int)]): Set[List[(Int,Int)]] = {\n\tval indices = (0 until 81) filter {notPlayed(initial,_)} toList\n\tdef sudokuIter(indices: List[Int]): Set[List[(Int,Int)]] = indices match {\n\t\tcase Nil => Set(initial)\n\t\tcase index::tail => for {\n\t\t\tboard <- sudokuIter(tail)\n\t\t\tk <- 1 until 10\n\t\t\tif isLegal(board, (index,k))\n\t\t} yield (index,k)::board        \n\t}\n\tsudokuIter(indices)\n}\n\ndef sudokuPlot(board: List[(Int,Int)]): String = {\n\tval out = Array.ofDim[Int](9,9)\n\tfor {move <- board} out(move._1 / 9)(move._1 % 9) = move._2\n\tout.map({_.mkString(\" \")}).mkString(\"\\n\")\n}\n\ndef main(args: Array[String]) {\n\t//example problem from 6-17\n\tval initial = List((0,5),(1,3),(4,7),(9,6),(12,1),(13,9),(14,5),(19,9),(20,8),(25,6),(27,8),(31,6),(35,3),(36,4),(39,8),(41,3),(44,1),(45,7),(49,2),(53,6),(55,6),(60,2),(61,8),(66,4),(67,1),(68,9),(71,5),(76,8),(79,7),(80,9))\n\tprintln(sudokuPlot(initial))\n\tprintln(\"\\n\")\n\tprintln(sudokuPlot(sudokuSolve(initial).toList.head))\n}","dateUpdated":"Feb 11, 2016 4:48:19 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1455237985192_-2030918461","id":"20160211-164625_2098782123","dateCreated":"Feb 11, 2016 4:46:25 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:373"}],"name":"sfds-lab3","id":"2BBHN19YD","angularObjects":{"2BBX9KVBV":[],"2B9T31FJZ":[],"2BC97GWDB":[],"2BBRY8E4A":[],"2BBJF778P":[],"2BADXE7AU":[],"2BCSZYWYA":[],"2BC6W6857":[],"2BBBV3PP8":[],"2B956YWNV":[],"2BB6YM4DJ":[],"2B92D2YFF":[],"2BBG6HC2F":[],"2BAQREC7J":[]},"config":{"looknfeel":"default"},"info":{}}